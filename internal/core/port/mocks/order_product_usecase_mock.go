// Code generated by MockGen. DO NOT EDIT.
// Source: internal/core/port/order_product_usecase_port.go
//
// Generated by this command:
//
//	mockgen -source=internal/core/port/order_product_usecase_port.go -destination=internal/core/port/mocks/order_product_usecase_mock.go
//

// Package mock_port is a generated GoMock package.
package mock_port

import (
	context "context"
	reflect "reflect"

	dto "github.com/FIAP-SOAT-G20/FIAP-TechChallenge-Fase2/internal/adapter/dto"
	gomock "go.uber.org/mock/gomock"
)

// MockListOrderProductsUseCase is a mock of ListOrderProductsUseCase interface.
type MockListOrderProductsUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockListOrderProductsUseCaseMockRecorder
	isgomock struct{}
}

// MockListOrderProductsUseCaseMockRecorder is the mock recorder for MockListOrderProductsUseCase.
type MockListOrderProductsUseCaseMockRecorder struct {
	mock *MockListOrderProductsUseCase
}

// NewMockListOrderProductsUseCase creates a new mock instance.
func NewMockListOrderProductsUseCase(ctrl *gomock.Controller) *MockListOrderProductsUseCase {
	mock := &MockListOrderProductsUseCase{ctrl: ctrl}
	mock.recorder = &MockListOrderProductsUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockListOrderProductsUseCase) EXPECT() *MockListOrderProductsUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockListOrderProductsUseCase) Execute(ctx context.Context, input dto.ListOrderProductsInput) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, input)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockListOrderProductsUseCaseMockRecorder) Execute(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockListOrderProductsUseCase)(nil).Execute), ctx, input)
}

// MockCreateOrderProductUseCase is a mock of CreateOrderProductUseCase interface.
type MockCreateOrderProductUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockCreateOrderProductUseCaseMockRecorder
	isgomock struct{}
}

// MockCreateOrderProductUseCaseMockRecorder is the mock recorder for MockCreateOrderProductUseCase.
type MockCreateOrderProductUseCaseMockRecorder struct {
	mock *MockCreateOrderProductUseCase
}

// NewMockCreateOrderProductUseCase creates a new mock instance.
func NewMockCreateOrderProductUseCase(ctrl *gomock.Controller) *MockCreateOrderProductUseCase {
	mock := &MockCreateOrderProductUseCase{ctrl: ctrl}
	mock.recorder = &MockCreateOrderProductUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCreateOrderProductUseCase) EXPECT() *MockCreateOrderProductUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockCreateOrderProductUseCase) Execute(ctx context.Context, input dto.CreateOrderProductInput) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, input)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockCreateOrderProductUseCaseMockRecorder) Execute(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockCreateOrderProductUseCase)(nil).Execute), ctx, input)
}

// MockGetOrderProductUseCase is a mock of GetOrderProductUseCase interface.
type MockGetOrderProductUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockGetOrderProductUseCaseMockRecorder
	isgomock struct{}
}

// MockGetOrderProductUseCaseMockRecorder is the mock recorder for MockGetOrderProductUseCase.
type MockGetOrderProductUseCaseMockRecorder struct {
	mock *MockGetOrderProductUseCase
}

// NewMockGetOrderProductUseCase creates a new mock instance.
func NewMockGetOrderProductUseCase(ctrl *gomock.Controller) *MockGetOrderProductUseCase {
	mock := &MockGetOrderProductUseCase{ctrl: ctrl}
	mock.recorder = &MockGetOrderProductUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetOrderProductUseCase) EXPECT() *MockGetOrderProductUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockGetOrderProductUseCase) Execute(ctx context.Context, input dto.GetOrderProductInput) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, input)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockGetOrderProductUseCaseMockRecorder) Execute(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetOrderProductUseCase)(nil).Execute), ctx, input)
}

// MockUpdateOrderProductUseCase is a mock of UpdateOrderProductUseCase interface.
type MockUpdateOrderProductUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockUpdateOrderProductUseCaseMockRecorder
	isgomock struct{}
}

// MockUpdateOrderProductUseCaseMockRecorder is the mock recorder for MockUpdateOrderProductUseCase.
type MockUpdateOrderProductUseCaseMockRecorder struct {
	mock *MockUpdateOrderProductUseCase
}

// NewMockUpdateOrderProductUseCase creates a new mock instance.
func NewMockUpdateOrderProductUseCase(ctrl *gomock.Controller) *MockUpdateOrderProductUseCase {
	mock := &MockUpdateOrderProductUseCase{ctrl: ctrl}
	mock.recorder = &MockUpdateOrderProductUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpdateOrderProductUseCase) EXPECT() *MockUpdateOrderProductUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockUpdateOrderProductUseCase) Execute(ctx context.Context, input dto.UpdateOrderProductInput) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, input)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockUpdateOrderProductUseCaseMockRecorder) Execute(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockUpdateOrderProductUseCase)(nil).Execute), ctx, input)
}

// MockDeleteOrderProductUseCase is a mock of DeleteOrderProductUseCase interface.
type MockDeleteOrderProductUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockDeleteOrderProductUseCaseMockRecorder
	isgomock struct{}
}

// MockDeleteOrderProductUseCaseMockRecorder is the mock recorder for MockDeleteOrderProductUseCase.
type MockDeleteOrderProductUseCaseMockRecorder struct {
	mock *MockDeleteOrderProductUseCase
}

// NewMockDeleteOrderProductUseCase creates a new mock instance.
func NewMockDeleteOrderProductUseCase(ctrl *gomock.Controller) *MockDeleteOrderProductUseCase {
	mock := &MockDeleteOrderProductUseCase{ctrl: ctrl}
	mock.recorder = &MockDeleteOrderProductUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeleteOrderProductUseCase) EXPECT() *MockDeleteOrderProductUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockDeleteOrderProductUseCase) Execute(ctx context.Context, input dto.DeleteOrderProductInput) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, input)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockDeleteOrderProductUseCaseMockRecorder) Execute(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockDeleteOrderProductUseCase)(nil).Execute), ctx, input)
}
