// Code generated by MockGen. DO NOT EDIT.
// Source: internal/core/port/product_usecase_port.go
//
// Generated by this command:
//
//	mockgen -source=internal/core/port/product_usecase_port.go -destination=internal/core/port/mocks/product_usecase_mock.go
//

// Package mock_port is a generated GoMock package.
package mock_port

import (
	context "context"
	reflect "reflect"

	dto "github.com/FIAP-SOAT-G20/FIAP-TechChallenge-Fase2/internal/adapter/dto"
	gomock "go.uber.org/mock/gomock"
)

// MockListProductsUseCase is a mock of ListProductsUseCase interface.
type MockListProductsUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockListProductsUseCaseMockRecorder
	isgomock struct{}
}

// MockListProductsUseCaseMockRecorder is the mock recorder for MockListProductsUseCase.
type MockListProductsUseCaseMockRecorder struct {
	mock *MockListProductsUseCase
}

// NewMockListProductsUseCase creates a new mock instance.
func NewMockListProductsUseCase(ctrl *gomock.Controller) *MockListProductsUseCase {
	mock := &MockListProductsUseCase{ctrl: ctrl}
	mock.recorder = &MockListProductsUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockListProductsUseCase) EXPECT() *MockListProductsUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockListProductsUseCase) Execute(ctx context.Context, input dto.ListProductsInput) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, input)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockListProductsUseCaseMockRecorder) Execute(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockListProductsUseCase)(nil).Execute), ctx, input)
}

// MockCreateProductUseCase is a mock of CreateProductUseCase interface.
type MockCreateProductUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockCreateProductUseCaseMockRecorder
	isgomock struct{}
}

// MockCreateProductUseCaseMockRecorder is the mock recorder for MockCreateProductUseCase.
type MockCreateProductUseCaseMockRecorder struct {
	mock *MockCreateProductUseCase
}

// NewMockCreateProductUseCase creates a new mock instance.
func NewMockCreateProductUseCase(ctrl *gomock.Controller) *MockCreateProductUseCase {
	mock := &MockCreateProductUseCase{ctrl: ctrl}
	mock.recorder = &MockCreateProductUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCreateProductUseCase) EXPECT() *MockCreateProductUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockCreateProductUseCase) Execute(ctx context.Context, input dto.CreateProductInput) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, input)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockCreateProductUseCaseMockRecorder) Execute(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockCreateProductUseCase)(nil).Execute), ctx, input)
}

// MockGetProductUseCase is a mock of GetProductUseCase interface.
type MockGetProductUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockGetProductUseCaseMockRecorder
	isgomock struct{}
}

// MockGetProductUseCaseMockRecorder is the mock recorder for MockGetProductUseCase.
type MockGetProductUseCaseMockRecorder struct {
	mock *MockGetProductUseCase
}

// NewMockGetProductUseCase creates a new mock instance.
func NewMockGetProductUseCase(ctrl *gomock.Controller) *MockGetProductUseCase {
	mock := &MockGetProductUseCase{ctrl: ctrl}
	mock.recorder = &MockGetProductUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGetProductUseCase) EXPECT() *MockGetProductUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockGetProductUseCase) Execute(ctx context.Context, input dto.GetProductInput) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, input)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockGetProductUseCaseMockRecorder) Execute(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetProductUseCase)(nil).Execute), ctx, input)
}

// MockUpdateProductUseCase is a mock of UpdateProductUseCase interface.
type MockUpdateProductUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockUpdateProductUseCaseMockRecorder
	isgomock struct{}
}

// MockUpdateProductUseCaseMockRecorder is the mock recorder for MockUpdateProductUseCase.
type MockUpdateProductUseCaseMockRecorder struct {
	mock *MockUpdateProductUseCase
}

// NewMockUpdateProductUseCase creates a new mock instance.
func NewMockUpdateProductUseCase(ctrl *gomock.Controller) *MockUpdateProductUseCase {
	mock := &MockUpdateProductUseCase{ctrl: ctrl}
	mock.recorder = &MockUpdateProductUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpdateProductUseCase) EXPECT() *MockUpdateProductUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockUpdateProductUseCase) Execute(ctx context.Context, input dto.UpdateProductInput) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, input)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockUpdateProductUseCaseMockRecorder) Execute(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockUpdateProductUseCase)(nil).Execute), ctx, input)
}

// MockDeleteProductUseCase is a mock of DeleteProductUseCase interface.
type MockDeleteProductUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockDeleteProductUseCaseMockRecorder
	isgomock struct{}
}

// MockDeleteProductUseCaseMockRecorder is the mock recorder for MockDeleteProductUseCase.
type MockDeleteProductUseCaseMockRecorder struct {
	mock *MockDeleteProductUseCase
}

// NewMockDeleteProductUseCase creates a new mock instance.
func NewMockDeleteProductUseCase(ctrl *gomock.Controller) *MockDeleteProductUseCase {
	mock := &MockDeleteProductUseCase{ctrl: ctrl}
	mock.recorder = &MockDeleteProductUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDeleteProductUseCase) EXPECT() *MockDeleteProductUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockDeleteProductUseCase) Execute(ctx context.Context, input dto.DeleteProductInput) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, input)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockDeleteProductUseCaseMockRecorder) Execute(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockDeleteProductUseCase)(nil).Execute), ctx, input)
}
